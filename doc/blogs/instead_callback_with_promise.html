<h3>Instead callback of Promise</h3>

<p>As the ES6 came, we could solve the <strong>callback hell</strong> with the new functionality called <strong><em>Promise</em></strong>.<br>
    When we use javascript in browser or node.js, the tricky problem around us that <strong><em>callback
        hell</em></strong>, it cause by javascript characteristic: that single t ead and callback function.<br>
    For example,when we want to get something from database, we use a callback function which will call when the
    database finish query, consider follow code:</p>

<pre><code class="language-javascript"><span class="hljs-keyword">const</span> MongoClient = <span
        class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>).MongoClient

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ifError</span>(<span
        class="hljs-params">err, fun</span>) </span>{
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-built_in">console</span>.log(err)
    } <span class="hljs-keyword">else</span> {
        fun()
    }
}

router.get(
    <span class="hljs-string">'/'</span>,
    (req, res) =&gt; {
        <span class="hljs-keyword">const</span> url = <span
            class="hljs-string">'mongodb://localhost:27017/myProject'</span>
        MongoClient.connect(
            url,
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span
                    class="hljs-params">err, db</span>) </span>{
                ifError(
                    err,
                    () =&gt; {
                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Connected successfully to server"</span>)
                        <span class="hljs-keyword">let</span> collection = db.collection(<span class="hljs-string">'documents'</span>)
                        collection.find({}).toArray(
                            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span
                                    class="hljs-params">err, docs</span>) </span>{
                                ifError(
                                    err,
                                    () =&gt; {
                                        res.json(docs)
                                        db.close()
                                    })
                            })
                    })
            })
    }
)
</code></pre>

<p>In above example, we write a handler for respond all item in collection <strong>documents</strong> in mongodb
    ,however, we fail <strong>callback hell</strong> in this case.</p>


<p>First, we create a function that accept a err,if err, we console it, else we call the fun as callback.</p>


<p>Second, we connect database, the mongodb driver’s <strong>connect</strong> function will accept a
    <strong>url</strong> that specify the url consist of host and port as well as which database we will connect,the
    second argument is a function which will call we connect operation finish, it accept two argument:
    <strong>err</strong> if err occur<br>
    and <strong>db</strong> which is a object wrap some method as connect operation result.</p>


<p><strong><em>Then</em></strong>, <strong>connect</strong> method 's callback function, we get the collection
    <strong>document</strong>, and find all document in this collection.</p>


<p>However,this code is hard to read, we callback in callback, finally, we get triangle shape code.<br>
    let me clarify what we do. We execute some operation,if err occur, we log it, if not,we execute other
    operation,if the new operation t ow some err, we log it as well, if not, execute some new operation…<br>
    Can it bw possible that clever way to do this?<br>
    Yes, the ES6 provide a new feature called <strong>Promise</strong>.<br>
    A <strong>Promise</strong> is a constructed function that accept a function (we will alias it as execute
    function) which accept two argument: <strong>resolve</strong> function and <strong>reject</strong> function.<br>
    The <strong>execute function</strong> will execute some code block,maybe a async onous operation and call
    <strong>resolve</strong> function or <strong>reject</strong> function(always when err occur).<br>
    Then <strong>Promise</strong> constructed function return a <strong>Promise</strong> object which wrap some
    methods,one of it is <strong>then</strong>.<br>
    The <strong>then</strong> method will accept one or two function. If one, it will executed when the
    <strong>Promise</strong>
    call <strong>resolve</strong> function and always do some async onous operation and return the new
    <strong>Promise</strong>.
    If two, same as one,but the second function will call when the <strong>Promise</strong> call
    <strong>reject</strong>.<br>
    With the <strong>then</strong> method, we could chain the async onous operation, it is hard to say, let us
    consider follow code:</p>

<pre><code class="language-javascript"><span class="hljs-keyword">const</span> MongoClient = <span
        class="hljs-built_in">require</span>(<span class="hljs-string">'mongodb'</span>).MongoClient
router.get(
   <span class="hljs-string">'/'</span>,
   (req, res) =&gt; {
       <span class="hljs-keyword">const</span> url = <span
            class="hljs-string">'mongodb://localhost:27017/myProject'</span>
       <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
           (resolve, reject) =&gt; {
               MongoClient.connect(url, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span
            class="hljs-params">err, db</span>) </span>{
                   <span class="hljs-keyword">if</span> (err) {
                       reject(err)
                   } <span class="hljs-keyword">else</span> {
                       resolve(db)
                   }
               })
           }
       )
           .then(
           (db) =&gt; db.collection(<span class="hljs-string">"documents"</span>)
       )
           .then(
               collection=&gt;collection.find().toArray()
           )
           .then(
               (docs)=&gt;res.json(docs)
           )
   }
)


<span class="hljs-keyword">const</span> MongoClient = <span class="hljs-built_in">require</span>(<span
            class="hljs-string">'mongodb'</span>).MongoClient
</code></pre>

<p>Above code do same thing with last code, but more readable.</p>


<p>First, we create a <strong>Promise</strong>,then do some async onous operation that connect database, if err
    occur, we call <strong>reject</strong> function, if not, call <strong>resolve</strong> function.</p>


<p>Then, we chain this <strong>Promise</strong> with some <strong>then</strong> methods, if not err occur, it will
    call one by one with async onous that mean the code next it will *<strong>not be block</strong>.If err occur,
    the <strong>err</strong> message will pass to the chain end <strong>catch</strong> which will log the err
    message.<br>
    That is all, thanks! If you wanna more deeply learn ES6 <strong>Promise</strong>,there was some nice blog maybe
    will help you:</p>
<ol>
    <li><a ef="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">developer.mozilla.org</a>
    </li>
    <li><a ef="https://developers.google.com/web/fundamentals/getting-started/primers/promises">google
        developer</a></li>
</ol>
   



